#include <avr/io.h>
#include <avr/interrupt.h>

void setup() {
    cli();  // Disable global interrupts

    // ------------------- PWM CONFIG: OC1B on D10 (PB2) -------------------
    TCCR1A = 0x21;  // Phase Correct PWM 8-bit (WGM10), Clear OC1B on compare match
    TCCR1B = 0x01;  // No prescaler, WGM13:0 = 0001
    TCCR1C = 0x00;
    TIMSK1 = 0x00;
    OCR1B = 0;      // Start with 0% duty cycle

    // ------------------- PIN CONFIGURATION -------------------
    DDRB |= 0x06;   // PB1 (D9 = Direction), PB2 (D10 = PWM) as outputs
    DDRD &= ~0x04;  // PD2 (D2 = direction switch) as input
    PORTD |= 0x04;  // Enable pull-up on D2 (PD2) — HIGH when open, LOW when pressed

    // ------------------- ADC CONFIGURATION -------------------
    ADMUX = 0x60;   // ADC0 (A0), AVCC reference, left-adjust result
    ADCSRA = 0xEF;  // Enable ADC, Start, Auto Trigger, Interrupt, Prescaler 128
    ADCSRB = 0x00;  // Free-running mode

    sei();  // Enable global interrupts
}

ISR(ADC_vect) {
    // Read potentiometer value (ADCH: 0–255)
    unsigned char pwm = ADCH;

    // Clamp low speeds to 0 to prevent buzzing
    // if (pwm < 80) {
    //     pwm = 0;
    // }

    OCR1B = pwm;  // Set PWM duty cycle on D10 (OC1B / PB2)

    // Read direction switch state from D2 (PD2)
    if ((PIND & 0x04) == 0) {
        // Switch pressed → reverse
        PORTB |= 0x02;   // D9 (PB1) HIGH → reverse
        OCR1B = pwm;  // Set PWM duty cycle on D10 (OC1B / PB2)
    } else {
        // Switch not pressed → forward
        PORTB &= ~0x02;  // D9 (PB1) LOW → forward
        OCR1B = ~pwm;  // Set PWM duty cycle on D10 (OC1B / PB2)
    }
}

void loop() {
    // Everything is handled in the ADC interrupt
}
